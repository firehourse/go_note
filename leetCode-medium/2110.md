# 2110 Number of Smooth Descent Periods of a Stock

```go
// 一開始覺得可以用dp解
// 用小畫家以後發現是個高斯加法
// 那首先我會需要知道當下與前項相減是否為1 接著我需要知道連續的1有幾個
// 那看起來這邊需要維護一個連續值
func getDescentPeriods(prices []int) int64 {
    // 先搞個dp 裡面則是連續的數量
    dp := make([]int,len(prices)+1)
    // 宣告一下sum變數
    sum := 1
    // 直接開始跑迴圈，最後一個數另外處理
    for i := 0;i < len(prices)-1; i++ {
        // 跑個if，因為用while要另外維護指針
        if prices[i]-prices[i+1] == 1 {
            sum += 1 
        } else {
            dp[sum] ++
            sum = 1
        }
    }
    dp[sum] ++ 
    var result int64 = 0
    // 開始算高斯加法
    for k, v := range dp {
        if v > 0 {
           result += int64(v) * gos(k)
        }
    }
    return result
    
}

func gos(n int) int64 {
    nn := int64(n)
    return nn * (nn + 1) / 2
}
```
那這邊問了GPT 其實我不需要這個DP的，因為實際上數學上，這整個加總還是一個高斯加法

隔了一天回來，其實應該說，當下就直接算出高斯然後加總，就可以得到答案了，所以直接把原本dp的地方改成result += gos(sum)
非常的輕鬆
```
// 一開始覺得可以用dp解
// 用小畫家以後發現是個高斯加法
// 那首先我會需要知道當下與前項相減是否為1 接著我需要知道連續的1有幾個
// 那看起來這邊需要維護一個連續值
func getDescentPeriods(prices []int) int64 {

    // 宣告一下sum變數
    var result int64 = 0
    sum := 1
    // 直接開始跑迴圈，最後一個數另外處理
    for i := 0;i < len(prices)-1; i++ {
        // 跑個if，因為用while要另外維護指針
        if prices[i]-prices[i+1] == 1 {
            sum += 1 
        } else {
            result += gos(sum)
            sum = 1
        }
    }
    result += gos(sum)

    return result
    
}

func gos(n int) int64 {
    nn := int64(n)
    return nn * (nn + 1) / 2
}